- Start Date: 2015-04-23
- RFC PR: (leave this empty)
- Spree Issue: (leave this empty)

# Abstract

Single Paragraph abstract of the feature covering motivation, detailed design, drawbacks, and alternatives.

# Motivation

Spree is an ecommerce framework that, like Rails, abstracts large amounts of its functionality into multiple gems.
This allows for a clear seperation of concerns and easier way to manage dependencies.
The technique Spree and Rails uses are to help modularize large amounts of functionality to remove monolithic application strcuture, yet not be a messy ball of spagetti microservices.
Welcome to macroservice.

The topic of this paper is on the Spree API (`spree_api`) "macroservice".
The Spree API depends on the Spree Core (`spree_core`) gem which is where it receives the majority of its business logic, helpers, and mailers.
While the Spree API is able to provide API endpoints to Spree Core, it falls short on performance, JSON API design, and client-side MVC support (read: EmberJS).

The motivation of RFC 001 is to build a second version of the Spree API with performance, JSON API best practice, and client-side support as the key motivators.

# Detailed Design

The current API of Spree is mature and covers a large amount of functionality.
The API uses [Rabl](https://github.com/nesquena/rabl) to render the API views, it does not follow the [JSON API Spec](http://jsonapi.org), and is not client side optimized.
The "V1 API" was built before the time of React and Ember and the JSON API Spec.

## JSON Serialization

Before looking at the JSON API Spec and client-side optimization, we should first identify _how_ the API could be built and serialized.
Rabl serializes JSON by using a ruby DSL with the files stored in the views folder.
The problem is serializing JSON from the views is:

  a. Expensive to locate the views in the file structure;
  b. JSON serialization is done through a response/request life cycle; and
  c. Rabl does not actively support Rails Engines (where a Rails application may have multiple view paths).

There are four popular ways to implement JSON serialization in Rails:

1. [`#to_json`](http://apidock.com/rails/ActiveRecord/Serialization/to_json): The fastest and simplest form of JSON serialization in ruby.
2. [JBuilder](https://github.com/rails/jbuilder): The default rails JSON serializer with maturity as its main pro.
3. [Rabl](https://github.com/nesquena/rabl): The current serializer that is framework agnostic.
4. [Active Model Serializers (AMS)](https://github.com/rails-api/active_model_serializers): A ruby JSON serializer via ruby classes instead of views.

The `#to_json` methodology is the most optimal implementation, but it falls short when serializing JSON data from a database.
Quite often, you can implement a SQL call to a DB and have the returned response as json instead of serializing it through ruby.

JBuilder, Rabl, and AMS are all equal candidates for the new JSON serializer, but due to Spree's size, the best tool for the job would the fastest tool.

A large amount of JBuilder and Rabl's performance issues are with the views.
AMS succeeds because its core ruby instead of having a dependency on the views.
Ontop of AMS's performance improvements, if the the attributes AMS is fetching are purely columnar, then the results could be fetched by a SQL call.
This means that users of PostgreSQL or MySQL might benefit from a gem.
For PostgreSQL there is [Postgres Ext Serializers](https://github.com/dockyard/postgres_ext-serializers).
And example SQL call, using the AMS API, is:

```sql
(WITH spree_products_attributes_filter AS (
  SELECT "spree_products"."id", "spree_products"."name", "spree_products"."slug", "spree_products"."description"
  FROM "spree_products" WHERE "spree_products"."deleted_at" IS NULL
), spree_products_as_json_array AS (
  SELECT COALESCE(json_agg(tbl), '[]')
  AS products, 1 
  AS match
  FROM (
    SELECT *
    FROM "spree_products_attributes_filter"
  )
  AS tbl
), jsons AS (
  SELECT "spree_products_as_json_array"."products"
  FROM "spree_products_as_json_array"
)
SELECT row_to_json(jsons)
FROM "jsons");
```

Its for this reason that I believe the Spree V2 API only include the column names.
If a person requires data such as full name, this can be easily done in Ember Data via  the `Ember.computed()` function:

```javascript
// app/models/product.js
import Ember from 'ember';
import DS from 'ember-data';

export default DS.Model.extend({
  name: DS.attr('string'),
  description: DS.attr('string'),
  slug: DS.attr('string'),
  variants: DS.hasMany('variant'),
  master: Ember.computed('variants', function() {
    return this.get('variants').findBy('isMaster', true);
  }),
  price: Ember.computed('master', function() {
    return this.get('master').get('price').get('amount');
  }),
  displayPrice: Ember.computed('master', function() {
    return this.get('master').get('displayPrice');
  })
});

// app/models/variant.js
import Ember from 'ember';
import DS from 'ember-data';

export default DS.Model.extend({
  isMaster: DS.attr('boolean'),
  product: DS.belongsTo('product'),
  price: DS.belongsTo('price'),
  displayPrice: Ember.computed('price', function() {
    return `$${this.get('price').get('amount').toFixed(2)}`;
  })
});

// app/models/price.js
import DS from 'ember-data';

export default DS.Model.extend({
  amount: DS.attr('number'),
  currency: DS.attr('string'),
  variant: DS.belongsTo('variant')
});
```

# Drawbacks

- AMS is not a mature gem. JBuilder is.
- This whole thing is ludicrous

Why should a developer *not* implement this feature?

# Alternatives

- Usage of JBuilder
- Simply rewrite API for rabl

# Unresolved Questions

What parts of the design are still to be decided?
