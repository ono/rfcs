- Start Date: 2015-04-23
- RFC PR: (leave this empty)
- Spree Issue: (leave this empty)

# Abstract

Single Paragraph abstract of the feature covering motivation, detailed design, drawbacks, and alternatives.

# Motivation

Spree is an ecommerce framework that, like Rails, abstracts large amounts of its functionality into multiple gems.
This allows for a clear seperation of concerns and easier way to manage dependencies.
The technique Spree and Rails uses are to help modularize large amounts of functionality to remove monolithic application strcuture, yet not be a messy ball of spagetti microservices.
Welcome to macroservice.

The topic of this paper is on the Spree API (`spree_api`) "macroservice".
The Spree API depends on the Spree Core (`spree_core`) gem which is where it receives the majority of its business logic, helpers, and mailers.
While the Spree API is able to provide API endpoints to Spree Core, it falls short on performance, JSON API design, and client-side MVC support (read: EmberJS).

The motivation of RFC 001 is to build a second version of the Spree API with performance, JSON API best practice, and client-side support as the key motivators.

# Detailed Design

The current API of Spree is mature and covers a large amount of functionality.
The API uses [Rabl](https://github.com/nesquena/rabl) to render the API views, it does not follow the [JSON API Spec](http://jsonapi.org), and is not client side optimized.
The "V1 API" was built before the time of React and Ember and the JSON API Spec.

## JSON Serialization

Before looking at the JSON API Spec and client-side optimization, we should first identify _how_ the API could be built and serialized.
Rabl serializes JSON by using a ruby DSL with the files stored in the views folder.
The problem is serializing JSON from the views is:

  a. Expensive to locate the views in the file structure;
  b. JSON serialization is done through a response/request life cycle; and
  c. Rabl does not actively support Rails Engines (where a Rails application may have multiple view paths).

There are four popular ways to implement JSON serialization in Rails:

1. [`#to_json`](http://apidock.com/rails/ActiveRecord/Serialization/to_json): The fastest and simplest form of JSON serialization in ruby.
2. [JBuilder](https://github.com/rails/jbuilder): The default rails JSON serializer with maturity as its main pro.
3. [Rabl](https://github.com/nesquena/rabl): The current serializer that is framework agnostic.
4. [Active Model Serializers (AMS)](https://github.com/rails-api/active_model_serializers): A ruby JSON serializer via ruby classes instead of views.

The `#to_json` methodology is the most optimal implementation, but it falls short when serializing JSON data from a database.
Quite often, you can implement a SQL call to a DB and have the returned response as json instead of serializing it through ruby.

JBuilder, Rabl, and AMS are all equal candidates for the new JSON serializer, but due to Spree's size, the best tool for the job would the fastest tool.

A large amount of JBuilder and Rabl's performance issues are with the views.
AMS succeeds because its core ruby instead of having a dependency on the views.
Ontop of AMS's performance improvements, if the the attributes AMS is fetching are purely columnar, then the results could be fetched by a SQL call.
This means that users of PostgreSQL or MySQL might benefit from a gem.
For PostgreSQL there is [Postgres Ext Serializers](https://github.com/dockyard/postgres_ext-serializers).
And example SQL call, using the AMS API, is:

```sql
(WITH spree_products_attributes_filter AS (
  SELECT "spree_products"."id", "spree_products"."name", "spree_products"."slug", "spree_products"."description"
  FROM "spree_products" WHERE "spree_products"."deleted_at" IS NULL
), spree_products_as_json_array AS (
  SELECT COALESCE(json_agg(tbl), '[]')
  AS products, 1 
  AS match
  FROM (
    SELECT *
    FROM "spree_products_attributes_filter"
  )
  AS tbl
), jsons AS (
  SELECT "spree_products_as_json_array"."products"
  FROM "spree_products_as_json_array"
)
SELECT row_to_json(jsons)
FROM "jsons");
```

Its for this reason that the Spree V2 API should only include the column names.
If a person requires data such as full name, this can be easily done in Ember Data via  the `Ember.computed()` function:

```javascript
// app/models/product.js
import Ember from 'ember';
import DS from 'ember-data';

export default DS.Model.extend({
  name: DS.attr('string'),
  description: DS.attr('string'),
  slug: DS.attr('string'),
  variants: DS.hasMany('variant'),
  master: Ember.computed('variants', function() {
    return this.get('variants').findBy('isMaster', true);
  }),
  price: Ember.computed('master', function() {
    return this.get('master').get('price').get('amount');
  }),
  displayPrice: Ember.computed('master', function() {
    return this.get('master').get('displayPrice');
  })
});

// app/models/variant.js
import Ember from 'ember';
import DS from 'ember-data';

export default DS.Model.extend({
  isMaster: DS.attr('boolean'),
  product: DS.belongsTo('product'),
  price: DS.belongsTo('price'),
  displayPrice: Ember.computed('price', function() {
    return `$${this.get('price').get('amount').toFixed(2)}`;
  })
});

// app/models/price.js
import DS from 'ember-data';

export default DS.Model.extend({
  amount: DS.attr('number'),
  currency: DS.attr('string'),
  variant: DS.belongsTo('variant')
});
```

What what if the users project is not using Ember?
Given Spree's large (but not monolithic) data, the developer should be expected to have a mature methodology for local data storage.
For [Angular](https://github.com/angular/angular.js) this would be [AngularData](https://github.com/js-data/js-data-angular).
For [React](https://github.com/facebook/react) this would be [Immutable](https://github.com/facebook/immutable-js).
For [Backbone](https://github.com/jashkenas/backbone) this would be... SoL for a standard data collection library.

Since manipulating data is expected at this level, then serializing data from business logic should either be kept to a minimum or not performed within ruby.
This means that the JSON serialization within Spree can have two benefits:

1. The JSON serialization can be performed at the DB level for some lucky individuals.
2. The JSON serialization will be far more performant since ruby doesn't have to serialize as much data.

## Formatting JSON Keys

In Javascript, the convention is to use lower camel casing instead of snake casing.
The current API uses snake casing.
The optimal request would therefore be:

```json
{
  "variant": {
    "id": 1,
    "isMaster": true
  }
}
```

Instead of:

```json
{
  "variant": {
    "id": 1,
    "is_master": true
  }
}
```

Lower camel casing is available in AMS 0.9, but can be made available for AMS 0.8 via this snippet of ruby code:

```ruby
# app/serializers/spree/base_serializer.rb
module Spree
  class BaseSerializer < ActiveModel::Serializer
    def serializable_hash
      Hash[super.to_a.map do |key, value|
        key = key.to_s.camelize
        [key[0, 1].downcase + key[1..-1], value]
      end]
    end
  end
end
```

## AMS API with Spree and Extensibility

If AMS is used for the second version of the Spree API, then a major conern should be the extensibility of the API.
With the current API, for a developer to add or remove functionality to a Rabl template, then they would have to completely overwrite that template.
There are three cases that need to be looked at for ensuring Spree is extensible and developer friendly with AMS:

1. Adding an attribute.
2. Editing an attribute.
3. Removing an attribute.

Given this serializer:

```ruby
# app/serializers/spree/product_serializer.rb
module Spree
  class ProductSerializer < Spree::BaseSerializer
    attributes :id, :name, :description, :slug
  end
end
```

Imagine you added an association so that a product would `belong_to :store`.
How would you go about adding that attribute?
In AMS this would be done as so:

```ruby
# app/serializers/spree/product_serializer_decorator.rb
Spree::ProductSerializer.class_eval do
  attributes :store_id
end
```

What if the developer wanted to have the name capitalized?

```ruby
# app/serializers/spree/product_serializer_decorator.rb
Spree::ProductSerializer.class_eval do
  def name
    super.capitalize
  end
end
```

What if a developer is not using an attribute for their project and wants to improve performance.
They may not be using the slug attribute and would like to remove this.
There is no clear, intuitive way to perform this with the current implementation.

A more developer-friendly implementation would be:

```ruby
# app/serializers/spree/product_serializer.rb
module Spree
  class ProductSerializer < Spree::BaseSerializer
    # Parenthesis added to avoid confusion from splat vs. multiplication.
    attributes(*attribute_keys)

    def self.attribute_keys
      [:id, :name, :description, :slug]
    end
  end
end
```

This way, if a developer would like to remove an attribute, they may do as so:

```ruby
# app/serializers/spree/product_serializer_decorator.rb
Spree::ProductSerializer.class_eval do
  def self.attribute_keys
    [:id, :name, :description]
  end
end
```

As you can see in the above example, this not very optimal.
To allow for a more robust solution (and the usage of `super`) a more optimal solution would be:

```ruby
# app/serializers/spree/base_serializer.rb
module Spree
  class BaseSerializer < ActiveModel::Serializer
    attributes(*attribute_keys)

    def self.attribute_keys
      name.sub('Serializer', '').constantize.column_names
    end
  end
end

# app/serializers/spree/product_serializer.rb
module Spree
  class ProductSerializer < Spree::BaseSerializer
  end
end

# app/serializers/spree/product_serializer_decorator.rb
Spree::ProductSerializer.class_eval do
  self.attribute_keys
    super - %w(slug)
  end
end
```

For associations, there is no need to add a `has_many` or `has_one` to the AMS serializer since the IDs are already stored as a column name.
If a developer would like to add an association, that may be done via their own code and not from Spree.

# Drawbacks

- AMS is not a mature gem. JBuilder is.
- This whole thing is ludicrous

Why should a developer *not* implement this feature?

# Alternatives

- Usage of JBuilder
- Simply rewrite API for rabl

# Unresolved Questions

What parts of the design are still to be decided?
